<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   xmlns:skins="skins.*"
					   xmlns:myComp="myComp.*"
					   width="1000"
					   height="700"
					   minWidth="1000"
					   minHeight="700"
					   creationComplete="init()"
					   showStatusBar="false"
					   titleIcon="{titleIconClass}"
					   >
	<fx:Declarations>
		<!-- Placer ici les éléments non visuels (services et objets de valeur, par exemple). -->
	</fx:Declarations>
	
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.collections.XMLListCollection;
			import mx.controls.DataGrid;
			import mx.core.SoundAsset;
			import mx.events.CloseEvent;
			import mx.events.ListEvent;
			import mx.managers.CursorManager;
			import mx.managers.PopUpManager;
			
			import myComp.Alerte;
			
			
			/** URL vers le serveur de sciences po. */
			private var URL:String = "http://www.sciencespo.fr/evenements/";
			
			/** Nom de salles. */
			private const SALLE_1:String = "Amphithéâtre";
			private const SALLE_2:String = "Retransmission";
			
			
			/** Nombre de chiffres dans le code barre. */
			private const CB_LENGTH:Number = 13;
			
			
			/** Couleurs de l'application. */
			private const COULEUR_FOND:Number = 0xE6E7E8;
			private const COULEUR_ROUGE:Number = 0xCB021A;
			private const COULEUR_VERTE:Number = 0x02BA1A;
			private const COULEUR_BLEUE:Number = 0x021ACB;
			private const COULEUR_MENU:Number = 0x1A1A1A;
			private const COULEUR_TEXTE:Number = 0x1A1A1A;
			private const COULEUR_TEXTE_MENU:Number = 0xFFFFFF;
			private const COULEUR_SAUMON:Number = 0xF9E5E8;
			private const COULEUR_FLASH_OK_1:Number = 0x00FF00;
			private const COULEUR_FLASH_OK_2:Number = 0x0000FF;
			
			
			[Bindable]
			/** Stocke l'état du plein écran (true || false) */
			private var fullscreen_state:Boolean = false;
			
			
			private var listeConferencesLoader:URLLoader;
			/** Stocke la liste des conférences. */
			private var listeConfXML:XML;
			
			
			private var conferenceLoader:URLLoader;
			/** Stocke les détails d'une conférence. */
			private var confXML:XML;    
			
			
			[Bindable]
			/** Stocke l'état de la connexion internet. */
			private var etatInternet:Boolean = false;
			
			
			[Bindable]
			/** Stocke la conférence sélectionnée. */
			private var conference:XMLList;
			
			[Bindable]
			/** Stocke l'utilisateur scanné. */
			private var utilisateur:XMLList;
			
			
			[Bindable]
			/** Affiche l'état de l'utilisateur scanné à droite des ses informations (OK, !, ...). */
			private var etatUtilisateur:String;
			
			
			[Bindable]
			/** Affiche la salle de l'utilisateur scanné. */
			private var salleUtilisateur:String;
			
			
			private var alerte:Alerte = new Alerte();
			/** Fait passer la fonction à éxécuter lors de la fermeture d'une fenêtre d'alerte. */
			private var alerteCloseHandler:Function;
			
			/** 
			 * Variable servant à savoir si une fenêtre d'alerte a été affichée pour empêcher
			 * la soumission du code barre si fermeture avec la touche "Entrée".
			 */
			private var alerteScanVisible:Boolean;
			
			
			/** 
			 * Variable servant à connaître l'état de la fenêtre Alert 
			 * en cas de clic sur la croix rouge de la fenêtre
			 * et éviter que plusieurs Alert se superposent.
			 */
			private var alerteCloseVisible:Boolean;
			
			
			/**
			 * Variable servant à savoir si quitter application
			 * si sauvegarde CSV après avoir cliqué sur "Quitter".
			 */
			private var quitAfterSaveCSV:Boolean;
			
			
			/**
			 * Variable servant à savoir si la conférence a déjà été
			 * sauvegardée au format CSV.
			 */
			private var CSVsaved:Boolean;
			
			
			[Bindable]
			/** Stocke l'heure affichée dans l'entête. */
			private var heure:String;
			
			private var ticker:Timer = new Timer(1000);
			
			
			
			[Bindable]
			[Embed(source="assets/images/Logo_blanc.png")]
			/** Logo Science Po */
			private var logoBlancClass:Class;
			
			[Bindable]
			[Embed(source="assets/icones/32x32.png")]
			/** Icône Scan Event */
			private var titleIconClass:Class;
			
			[Bindable]
			[Embed(source="assets/sons/amphitheatre.mp3")]
			/** Son Amphithéâtre */
			private var sonAmphitheatreClass:Class;
			
			[Bindable]
			[Embed(source="assets/sons/retransmission.mp3")]
			/** Son Retransmission */
			private var sonRetransmissionClass:Class;
			
			[Bindable]
			[Embed(source="assets/sons/probleme.mp3")]
			/** Son Problème */
			private var sonProblemeClass:Class;
			
			private var sonAmphitheatre:SoundAsset;
			private var sonRetransmission:SoundAsset;
			private var sonProbleme:SoundAsset;
			
			
			
			/**
			 * Initialisation de l'application.
			 */			
			private function init():void
			{
				initWindow();
				recupURL();
				//testConnexionInternet();
				lancerTimerHeure();
				initSounds();
			}
			
						
			
			/**
			 * Initialisation de la fenêtre principale :
			 * - ajout d'un écouteur pour passer en plein écran au démarrage.
			 * - ajout d'un écouteur pour afficher une demande de confirmation
			 * à la fermeture de l'application.
			 * - ajout d'un écouteur au changement d'état du displayState
			 * pour remplacer la maximisation par le plein écran.
			 */
			private function initWindow():void
			{
				NativeApplication.nativeApplication.addEventListener(InvokeEvent.INVOKE, onInvoke);
				nativeWindow.addEventListener(Event.CLOSING, fermetureApplication);
				nativeWindow.addEventListener(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING, displayStateChangingApplication);
			}
			
			
			
			/**
			 * Appel au passage en plein écran
			 * à l'invocation de l'application.
			 */
			private  function onInvoke(event:InvokeEvent):void {
				stage.addEventListener(FullScreenEvent.FULL_SCREEN, fullscreenEvent);
				toggleFullScreen();
				stage.scaleMode = StageScaleMode.NO_SCALE;
				stage.align = StageAlign.TOP_LEFT;
			}
			
			
			
			/**
			 * Passage en plein écran.
			 */
			private function toggleFullScreen():void {
				stage.displayState = ( stage.displayState == StageDisplayState.FULL_SCREEN_INTERACTIVE ) ?
				StageDisplayState.NORMAL :
				StageDisplayState.FULL_SCREEN_INTERACTIVE;
			}			
			
			
			
			/**
			 * Interception de la maximisation de la fenêtre
			 * pour passer en plein écran à la place.
			 */
			private function displayStateChangingApplication(event:NativeWindowDisplayStateEvent):void
			{
				if(event.afterDisplayState == "maximized"){
					event.preventDefault();
					toggleFullScreen();
				}
			}
			
			
			
			/**
			 * Afficher ou masque le bouton "Plein ecran" lors d'un changement d'état.
			 */
			private function fullscreenEvent(event:FullScreenEvent):void
			{
				fullscreen_state = event.fullScreen;
			}
			
			
			
			/**
			 * Prévention de la fermeture de l'application pour
			 * proposer de sauvegarder en CSV si pas déjà effectué.
			 * Sinon, quitte l'application.
			 */
			private function fermetureApplication(event:Event = null):void
			{
				if(vues.selectedChild == vue_liste && CSVsaved == false){
					if(event != null){
						event.preventDefault();
					}
					if(alerteCloseVisible == false){
						alerteCloseVisible = true;
						popAlerte("VOUS QUITTEZ L’APPLICATION SANS AVOIR EXPORTÉ LES DONNÉES AU FORMAT EXCEL", "SAUVEGARDER AVANT", "QUITTER SANS", this, alerteCloseClickHandler);
					}
				} else {
					NativeApplication.nativeApplication.exit();
				}
			}
			
			
			
			/**
			 * Test la présence d'une connexion internet
			 * en essayant de récupérer la liste des
			 * conférences sur le serveur distant.
			 */
			private function testConnexionInternet():void
			{
				lbEtatConnexion.text = "Vérification de la connexion internet en cours...";
				
				recupListeConferences();
			}
			
			
			
			/**
			 * Récupère l'URL du serveur dans le fichier "URL.txt" situé sur le bureau.
			 * 
			 * Crée le fichier en y insérant l'URL actuelle s'il n'existe pas.
			 */
			private function recupURL():void
			{
				CursorManager.setBusyCursor();
				
				var urlFile:File = File.desktopDirectory;
				urlFile = urlFile.resolvePath("URL.txt");
				
				var fileStream:FileStream = new FileStream();
				if(urlFile.exists){
					fileStream.open(urlFile, FileMode.READ);
					URL = trim(fileStream.readMultiByte(urlFile.size, File.systemCharset));
					fileStream.close();
				} else {
					fileStream.open(urlFile, FileMode.WRITE);
					fileStream.writeUTFBytes(URL);
					fileStream.close();
				}
				
				CursorManager.removeBusyCursor();
				
				testConnexionInternet();
			}
			
			
			
			/**
			 * Initialisation des sons.
			 */
			private function initSounds():void
			{
				sonAmphitheatre = SoundAsset(new sonAmphitheatreClass());
				sonRetransmission = SoundAsset(new sonRetransmissionClass());
				sonProbleme = SoundAsset(new sonProblemeClass());
			}
			
			
			
			/**
			 * Récupération de la liste des
			 * conférences sur le serveur distant.
			 */
			private function recupListeConferences(_datemin:Date = null, _datemax:Date = null):void
			{
				CursorManager.setBusyCursor();
				
				if(dateChooser1 != null) dateChooser1.enabled = false;
				
				var request:URLRequest = new URLRequest(URL + "listing.php?conf");
				var variables:URLVariables = new URLVariables();
				variables.app = "AIR";
				
				if(_datemin != null && _datemax != null){
					//trace(_datemin.getTime() + " :: " + _datemax.getTime());
					variables.datemin = _datemin.getTime();
					variables.datemax = _datemax.getTime();
				}
				
				request.data = variables;
				request.method = URLRequestMethod.POST;
				
				listeConferencesLoader = new URLLoader();
				
				try {
					listeConferencesLoader.load(request);
				}
				catch (error:SecurityError)
				{
					trace("A SecurityError has occurred.");
				}
				
				listeConferencesLoader.addEventListener(IOErrorEvent.IO_ERROR, listeConferencesErrorHandler);
				listeConferencesLoader.addEventListener(Event.COMPLETE, listeConferencesCompleteHandler);
			}
			
			
			
			/**
			 * Test connexion internet réussi.
			 * Récupération liste conférences réussie.
			 * Traitement de la liste des conférences.
			 */
			private function listeConferencesCompleteHandler(event:Event):void {
				listeConferencesLoader.removeEventListener(IOErrorEvent.IO_ERROR, listeConferencesErrorHandler);
				listeConferencesLoader.removeEventListener(Event.COMPLETE, listeConferencesCompleteHandler);
				
				if(listeConferencesLoader.data){
					lbEtatConnexion.text = "Connexion internet détectée.";
					etatInternet = true;
				}
				
				vues.selectedChild = vue_download;
				listeConfXML = XML(listeConferencesLoader.data);
				
				callLater(function():void{confRepeater.dataProvider = listeConfXML..conference;});
				
				CursorManager.removeBusyCursor();
				
				if(dateChooser1 != null) dateChooser1.enabled = true;
			}
			
			
			
			/**
			 * Récupération liste conférences échoué.
			 * Test connexion internet échoué.
			 */
			private function listeConferencesErrorHandler(event:IOErrorEvent):void {
				//trace("Pas de connexion internet.");
				listeConferencesLoader.removeEventListener(IOErrorEvent.IO_ERROR, listeConferencesErrorHandler);
				listeConferencesLoader.removeEventListener(Event.COMPLETE, listeConferencesCompleteHandler);
				lbEtatConnexion.text = "Pas de connexion internet ou serveur indisponible.";
				etatInternet = false;
				vues.selectedChild = vue_download;
				CursorManager.removeBusyCursor();
			}
			
			
			
			private var loadingConference:Boolean = false;
			/**
			 * Clic sur une conférence de la page d'accueil.
			 */
			private function clickConference(event:MouseEvent):void
			{
				if(loadingConference == false){
					loadingConference = true;
					conference = XMLList(event.currentTarget.getRepeaterItem());
					//trace("ID CONF => " + conference.@id);
					getConferenceXML(conference.@id);
				}
			}
			
			
			
			/**
			 * Récupération du XML de la conférence en ligne.
			 */
			private function getConferenceXML(_id:Number):void
			{
				CursorManager.setBusyCursor();
				
				var request:URLRequest = new URLRequest(URL + "listing.php?conf=" + _id);
				
				var variables:URLVariables = new URLVariables();
				variables.app = "AIR";
				request.data = variables;
				request.method = URLRequestMethod.POST;
				
				conferenceLoader = new URLLoader();
				
				try {
					conferenceLoader.load(request);
				}
				catch (error:SecurityError)
				{
					trace("A SecurityError has occurred.");
				}
				
				conferenceLoader.addEventListener(IOErrorEvent.IO_ERROR, conferenceErrorHandler);
				conferenceLoader.addEventListener(Event.COMPLETE, conferenceCompleteHandler);
			}
			
			
			
			/**
			 * Récupération du XML de la conférence.
			 */
			private function conferenceCompleteHandler(event:Event):void {
				conferenceLoader.removeEventListener(IOErrorEvent.IO_ERROR, conferenceErrorHandler);
				conferenceLoader.removeEventListener(Event.COMPLETE, conferenceCompleteHandler);
				confXML = XML(conferenceLoader.data);
				vues.selectedChild = vue_liste;
				conference = confXML..informations;
				callLater(initDataGrid);
				loadingConference = false;
				CursorManager.removeBusyCursor();
			}
			
			
			
			/**
			 * Erreur lors de la tentative de récupération du XML de la conférence.
			 */
			private function conferenceErrorHandler(event:IOErrorEvent):void {
				conferenceLoader.removeEventListener(IOErrorEvent.IO_ERROR, conferenceErrorHandler);
				conferenceLoader.removeEventListener(Event.COMPLETE,conferenceCompleteHandler);
				vues.selectedChild = vue_download;
				loadingConference = false;
				CursorManager.removeBusyCursor();
			}
			
			
			
			/**
			 * Ouvre une fenêtre permettant de sélectionner 
			 * un fichier XML local à importer.
			 */
			private function selectLocalXML(event:MouseEvent):void
			{
				var fileToOpen:File = File.desktopDirectory;
				var xmlFilter:FileFilter = new FileFilter("Fichier XML", "*.xml");
				
				try 
				{
					fileToOpen.browseForOpen("Ouvrir", [xmlFilter]);
					fileToOpen.addEventListener(Event.SELECT, fileSelected);
				}
				catch (error:Error)
				{
					trace("Failed:", error.message);
				}
			}
			
			
			
			/**
			 * Fichier XML local sélectionné.
			 */
			private function fileSelected(event:Event):void 
			{
				var fileStream:FileStream = new FileStream();
				fileStream.open(event.target as File, FileMode.READ);
				confXML = XML(fileStream.readUTFBytes(fileStream.bytesAvailable));
				fileStream.close();
				vues.selectedChild = vue_liste;
				conference = confXML..informations;
				callLater(initDataGrid);
			}
			
			
			
			/**
			 * Ajoute le dataprovider au tableau et
			 * active la fonction de changement de couleur d'une ligne.
			 */
			private function initDataGrid():void
			{
				xmlDataGrid.dataProvider = confXML..inscrit;
				xmlDataGrid.rowColorFunction = selectStateColorXML;
				trierListe();
			}
			
			
			
			/**
			 * Fonction renvoyant la couleur de la ligne du tableau
			 * suivant l'attribut "registered" de chaque personne de la liste.
			 * Si registered != 0 => COULEUR_SAUMON
			 */
			private function selectStateColorXML(datagrid:DataGrid, dataIndex:int, color:uint):uint
			{
				var rColor:uint;
				var item:XML =  datagrid.dataProvider.getItemAt(dataIndex);
				var value:String = item.attribute("registered");
				if (value != "0") { rColor = COULEUR_SAUMON; }
				else rColor = color;
				return rColor;
			}
			
			
			
			/**
			 * Réinitialise la page de scan.
			 */
			private function initScan(event:Event):void
			{
				//trace("initScan()");
				utilisateur = null;
				etatUtilisateur = "";
				salleUtilisateur = "";
				codeInput.text = "";
				codeInput.editable = true;
				codeInput.setFocus();
				alerteCloseHandler = null;
				alerteScanVisible = false;
				alerteCloseVisible = false;
				CSVsaved = false;
				stage.addEventListener(KeyboardEvent.KEY_DOWN, keyboardDownEventListener);
				stage.addEventListener(KeyboardEvent.KEY_UP, keyboardUpEventListener);
			}
			
			
			
			/**
			 * Met le focus sur le champ texte lors d'un KEY_DOWN.
			 */
			private function keyboardDownEventListener(event:KeyboardEvent):void
			{
				if(event.keyCode != 13 && cbxRecherche.selected == false){
					codeInput.setFocus();
					alerteScanVisible = false;
				}
			}
			
			
			
			/**
			 * Timer pour appeler la fonction de soumission du code barre 200 milisecondes
			 * après le KEY_UP de la touche "Entrée" de la douchette, car il y a un délai entre la réception
			 * des données et l'affichage dans le champ texte.
			 */
			private var timerSoumission:Timer = new Timer(200, 1);
			
			/**
			 * Lancement du Timer de soumissionCodebarre lors d'un KEY_UP
			 * sur la touche "Entrée".
			 */
			private function keyboardUpEventListener(event:KeyboardEvent):void
			{
				if(event.keyCode == 13 && cbxRecherche.selected == false){ 
					if(alerteScanVisible == false){
						timerSoumission.addEventListener(TimerEvent.TIMER_COMPLETE, soumissionCodebarre);
						timerSoumission.start();
					} else {
						alerteScanVisible = false;
					}
				}
			}
		
			
			
			/**
			 * Vérification du code barre soumis.
			 */
			private function soumissionCodebarre(event:TimerEvent):void
			{
				if(event != null) timerSoumission.removeEventListener(TimerEvent.TIMER_COMPLETE, soumissionCodebarre); // Si null => clic sur bouton OK donc pas de timer.
				stage.removeEventListener(KeyboardEvent.KEY_DOWN, keyboardDownEventListener);
				stage.removeEventListener(KeyboardEvent.KEY_UP, keyboardUpEventListener);
				alerteScanVisible = false;
				var codebarre:String = codeInput.text;
				if(codebarre.length == CB_LENGTH){
					codeInput.text = "";
					chercherCodebarreListe(codebarre);
				} else {
					alerteScanVisible = true;
					popAlerte("LE CODE BARRE DOIT OBLIGATOIREMENT CONTENIR " + CB_LENGTH + " CHIFFRES", "OK", "", this, reinitListeners);
				}
			}
			
			
			
			/**
			 * Recherche le code barre dans la liste des inscrits.
			 */
			private function chercherCodebarreListe(_codebarre:String):void
			{
				var cbToFind:String = _codebarre;
				//trace("CODEBARRE => " + cbToFind);
				if(confXML..inscrit.(@code == cbToFind).elements("*").length() > 0){
					utilisateur = XMLList(confXML..inscrit.(@code == cbToFind)[0]); // Si plusieurs inscrits avec même code barre (ce qui ne devrait jamais arriver), récupère le premier.
					salleUtilisateur = conference..salle.(@id == utilisateur.@salle);
					etatUtilisateur = "";
					verifierUtilisateur();
				} else {
					utilisateur = null;
					salleUtilisateur = "";
					etatUtilisateur = "Numéro non reconnu !";
					alerteScanVisible = true;
					popAlerte("NUMÉRO NON RECONNU", "OK", "", this, reinitListeners);
				}
			}
			
			
			
			/**
			 * Vérification de l'état de l'inscrit.
			 * 
			 * Incrémentation des places occupées ou alerte de personne déjà enregistrée.
			 */
			private function verifierUtilisateur():void
			{
				if(utilisateur.@registered == 0){
					conference..salle.(@id == utilisateur.@salle).@presents++;
					conference..salle.(@id == utilisateur.@salle).@reste--;
					utilisateur.@registered = new Date().getTime();
					etatUtilisateur = "OK";
					utilisateur.@salle == "1" ? sonAmphitheatre.play() : sonRetransmission.play();
					flashScreen();
					if(etatInternet == true) postEstVenu(utilisateur.@code, utilisateur.@registered);
					reinitListeners();
				} else {
					personneDejaEnregistree();
				}
			}
			
			
			
			private var selectedRow:Object;
			/**
			 * Ajout d'une personne inscrite manuellement.
			 */
			private function ajoutInscritManuellement(event:ListEvent):void
			{
				selectedRow = event.currentTarget.selectedItem;
				xmlDataGrid.selectedItem = null;
				if(selectedRow.@registered > 0){
					personneDejaEnregistree();
				} else {
					alerteScanVisible = true;
					popAlerte("ATTENTION VOUS ALLEZ INSCRIRE MANUELLEMENT " + selectedRow.prenom + " " + selectedRow.nom + "\n" + selectedRow.@code + "\n" + this['SALLE_' + selectedRow.@salle], "VALIDER", "ANNULER", this, alerteAjoutInscritMHandler, (selectedRow.@salle == 1 ? COULEUR_VERTE : COULEUR_BLEUE));
				}
			}
			
			
			
			/**
			 * Affichage alerte personne déjà enregistrée + heure d'enregistrement.
			 */
			private function personneDejaEnregistree():void
			{
				etatUtilisateur = "Déjà enregistré !";
				alerteScanVisible = true;
				popAlerte("PERSONNE DÉJÀ ENREGISTRÉE À\n" + timestampToHeure(utilisateur.@registered), "OK", "", this, reinitListeners);
			}
			
			
			
			/**
			 * Résolution de l'alerte lors du doubleclic sur une personne inscrite de la liste.
			 */
			private function alerteAjoutInscritMHandler(event:CloseEvent):void
			{
				alerte.removeEventListener(CloseEvent.CLOSE, alerteCloseHandler);
				if(event.detail == 1) {
					chercherCodebarreListe(selectedRow.@code);
				} else {
					alerteScanVisible = false;
					codeInput.editable = true;
				}		
			}
			
			
			
			/**
			 * Ajout d'une personne non-inscrite.
			 */
			private function ajoutNonInscrit(node_salle:uint):void
			{
				conference..salles.salle[node_salle].@noninscrits++;
				conference..salles.salle[node_salle].@reste--;
				flashScreen();
			}
			
			
			
			/**
			 * Produit un flash si tout est OK pour la personne scannée.
			 */
			private function flashScreen():void
			{
				CSVsaved = false;
				rectFlashOK.visible = true;
				var timerFlash:Timer = new Timer(100, 1);
				timerFlash.addEventListener(TimerEvent.TIMER_COMPLETE,
					function():void{
						rectFlashOK.visible = false;
						timerFlash.removeEventListener(TimerEvent.TIMER_COMPLETE, function():void{rectFlashOK.visible = false; });
					}
				);
				timerFlash.start();
			}
			
			
			
			/**
			 * Suppression de l'écouteur de fermeture de la fenêtre Alerte.
			 * Focus sur le champ texte.
			 * Réactivation des écouteurs KEY_DOWN et KEY_UP.
			 */			
			private function reinitListeners(event:CloseEvent = null):void
			{	
				if(event != null){
					alerte.removeEventListener(CloseEvent.CLOSE, alerteCloseHandler);
				}
				codeInput.editable = true;
				stage.addEventListener(KeyboardEvent.KEY_DOWN, keyboardDownEventListener);
				stage.addEventListener(KeyboardEvent.KEY_UP, keyboardUpEventListener);
			}

			
			
			/**
			 * Clic sur le bouton "Retour à l'Accueil".
			 * Proposition d'enregistrement de la conférence sous forme de fichier XML.
			 * Yes : enregistrement de la conférence en XML.
			 * No : retour à l'accueil.
			 */
			private function clicBtAccueil(event:MouseEvent):void
			{
				popAlerte("VOUS ALLEZ REVENIR À L’ACCUEIL,\nSOUHAITEZ-VOUS SAUVEGARDER POUR PLUS TARD ?", "SAUVEGARDER", "NON", this, alerteAccueilClickHandler);
			}
			
			
			
			/**
			 * Résolution de l'alerte lors du clic sur le bouton "Retour à l'Accueil".
			 */
			private function alerteAccueilClickHandler(event:CloseEvent):void
			{
				alerte.removeEventListener(CloseEvent.CLOSE, alerteCloseHandler);
				codeInput.editable = true;
				if (event.detail == 1) {
					saveConfXML();
				} else {
					stage.removeEventListener(KeyboardEvent.KEY_DOWN, keyboardDownEventListener);
					stage.removeEventListener(KeyboardEvent.KEY_UP, keyboardUpEventListener);
					testConnexionInternet();
				}
			}
			
						
			
			private var desktopDir:File;
			/**
			 * Enregistrement de la conférence sous forme de fichier XML.
			 * 
			 * Si une erreur survient pendant l'enregistrement,
			 * propose de réessayer. Sinon retourne à l'accueil.
			 */			
			private function saveConfXML():void
			{
				desktopDir = File.desktopDirectory.resolvePath(conference..titre + ".xml");
				try
				{
					desktopDir.browseForSave("Enregistrer sous...");
					desktopDir.addEventListener(Event.SELECT, saveXML);
				}
				catch (error:Error)
				{
					desktopDir.removeEventListener(Event.SELECT, saveXML);
					popAlerte(String("L'enregistrement du fichier a échoué.\n\nVoulez réessayer ?").toUpperCase(), "SAUVEGARDER", "NON", this, alerteAccueilClickHandler);
				}
			}
			
			
			
			/**
			 * Enregistrement du fichier XML.
			 */			
			private function saveXML(event:Event):void 
			{
				CursorManager.setBusyCursor();
				desktopDir.removeEventListener(Event.SELECT, saveXML);
				var newFile:File = event.target as File;
				var stream:FileStream = new FileStream();
				stream.open(newFile, FileMode.WRITE);
				stream.writeUTFBytes(confXML);
				stream.close();
				CursorManager.removeBusyCursor();
				popAlerte(String("Le fichier a bien été sauvegardé !").toUpperCase(), "OK", "", this, function():void {testConnexionInternet();});
			}
			
			
			
			/**
			 * Enregistrement de la conférence sous forme de fichier CSV.
			 * 
			 * Si une erreur survient pendant l'enregistrement,
			 * propose de réessayer. Sinon retourne à l'accueil.
			 */			
			private function saveConfCSV(_quitter:Boolean = false):void
			{
				quitAfterSaveCSV = _quitter;
				desktopDir = File.desktopDirectory.resolvePath(conference..titre + ".csv");
				try
				{
					desktopDir.browseForSave("Enregistrer sous...");
					desktopDir.addEventListener(Event.SELECT, saveCSV);
				}
				catch (error:Error)
				{
					desktopDir.removeEventListener(Event.SELECT, saveCSV);
					popAlerte(String("L'enregistrement du fichier a échoué.\n\nVoulez réessayer ?").toUpperCase(), "SAUVEGARDER", "NON", this, alerteAccueilClickHandler);
				}
			}
			
			
			
			/**
			 * Ecriture du fichier CSV.
			 */			
			private function saveCSV(event:Event):void
			{
				CursorManager.setBusyCursor();
				desktopDir.removeEventListener(Event.SELECT, saveXML);
				var newFile:File = event.target as File;
				var stream:FileStream = new FileStream();
				stream.open(newFile, FileMode.WRITE);
				stream.writeUTFBytes(parserXMLenCSV());
				stream.close();
				CSVsaved = true;
				CursorManager.removeBusyCursor();
				if(quitAfterSaveCSV == false){
					popAlerte(String("Le fichier a bien été sauvegardé !").toUpperCase());
				} else {
					popAlerte(String("Le fichier a bien été sauvegardé !").toUpperCase(), "QUITTER", "", this, function():void {NativeApplication.nativeApplication.exit();});
				}
			}
			
			
			
			/**
			 * Fonction parsant le XML en CSV pour l'export.
			 */
			private function parserXMLenCSV():String
			{
				//trace("parserXMLenCSV()");
				var dataCSV:String = new String();
				dataCSV = "Date inscription : ;Nom : ; Prénom : ; Mail : ;Entreprise : ;Fonction : ; Salle : ;Statut : ; Enregistré :\n";
				for each(var data:XML in confXML..inscrit){
					dataCSV += data.@date_inscrit + ";";
					dataCSV += data.nom + ";";
					dataCSV += data.prenom + ";";
					dataCSV += data.@mail + ";";
					dataCSV += data.@entreprise + ";";
					dataCSV += data.@fonction + ";";
					dataCSV += this["SALLE_" + data.@salle] + ";";
					dataCSV += data.@statut + ";";
					dataCSV += data.@registered + "\n";
				}
				var _date:Date = new Date();				
				dataCSV += _date.getFullYear() + "-" + (_date.getMonth()+ 1) + "-" + _date.getDate() + ";";
				dataCSV += "Non inscrit;";
				dataCSV += " ; ; ; ;";
				dataCSV += SALLE_1 + ";";
				dataCSV += " ;";
				dataCSV += conference..salles.salle[0].@noninscrits + "\n";
				
				dataCSV += _date.getFullYear() + "-" + (_date.getMonth()+ 1) + "-" + _date.getDate() + ";";
				dataCSV += "Non inscrit;";
				dataCSV += " ; ; ; ;";
				dataCSV += SALLE_2 + ";";
				dataCSV += " ;";
				dataCSV += conference..salles.salle[1].@noninscrits + "\n";
				
				return dataCSV;
			}
			
			
			
			/**
			 * Renvoie une date reçue sous forme AAAA-MM-JJ en JJ-MM.
			 */
			private function formaterDate(_date:String):String
			{
				var dateArrayAMJ:Array = _date.split("-");
				return(dateArrayAMJ[2] + "/" + dateArrayAMJ[1]);				
			}
			
			
			
			/**
			 * Renvoie un horaire reçu sous forme HH:MM:SS en HH:MM
			 * utilisé dans l'affichage de la liste des conférences.
			 */
			private function formaterHoraire(_horaire:String):String
			{
				var horaireArrayHMS:Array = _horaire.split(":");
				return(horaireArrayHMS[0] + "h" + horaireArrayHMS[1]);				
			}
			
			
			
			/**
			 * Fonction gérant l'alternance de la couleur du fond
			 * des boutons de la liste des conférences.
			 */
			private function boutConfAltColor(_index:Number):Number
			{
				if(_index/2 == Math.round(_index/2)){
					return COULEUR_SAUMON;
				} else {
					return 0xFFFFFF;
				}
			}
			
			
			
			/**
			 * Affiche une fenêtre popup.
			 */
			private function popAlerte(_message:String, _yesLabel:String = "OK", _noLabel:String="", _parent:Sprite = null, _alerteCloseHandler:Function=null, _couleur_fond:Number=COULEUR_ROUGE):void
			{
				codeInput.editable = false;
				alerteCloseHandler = _alerteCloseHandler;
				alerte._parent = _parent;
				alerte.yesLabel = _yesLabel;
				alerte.noLabel = _noLabel;
				alerte.message = _message;
				alerte.couleur_fond = _couleur_fond;
				if(alerteCloseHandler != null){
					if(alerteCloseHandler == alerteCloseClickHandler) alerte.bt_annulerQuitter = true; // Affiche troisième bouton "ANNULER" si clic sur bouton "Quitter".
					alerte.addEventListener(CloseEvent.CLOSE, alerteCloseHandler);
				}
				PopUpManager.addPopUp(alerte, this, true);
				sonProbleme.play();
			}
			
			
			
			/**
			 * Fermeture de l'application ou export CSV avant.
			 */
			private function alerteCloseClickHandler(event:CloseEvent):void
			{
				alerte.removeEventListener(CloseEvent.CLOSE, alerteCloseHandler);
				alerteCloseVisible = false;
				codeInput.editable = true;
				if(event.detail == 0) {
					NativeApplication.nativeApplication.exit();
				} else if (event.detail == 1){
					saveConfCSV(true);
				}
			}
			
			
			
			private var estVenuLoader:URLLoader;
			/**
			 * Envoi d'une requête POST en ligne 
			 * si la personne est venue.
			 */
			private function postEstVenu(_id:Number, _horaire:Number):void
			{				
				var request:URLRequest = new URLRequest(URL + "est_venu.php");
				
				var variables:URLVariables = new URLVariables();
				variables.app = "AIR";
				variables.presents = _id;
				variables.horaire = _horaire;
				
				request.data = variables;
				request.method = URLRequestMethod.POST;
				
				estVenuLoader = new URLLoader();
				
				try {
					estVenuLoader.load(request);
				}
				catch (error:SecurityError)
				{
					trace("A SecurityError has occurred.");
				}
			}
			
			
			
			/**
			 * Lance le timer affichant l'heure dans l'entête.
			 */
			private function lancerTimerHeure():void
			{
				ticker.addEventListener(TimerEvent.TIMER, afficherHeure);
				ticker.start();
			}
			
			
			
			/**
			 * Affiche l'heure dans l'entête.
			 */
			private function afficherHeure(event:TimerEvent):void
			{
				heure = timestampToHeure(new Date().getTime());
			}
			
			
			
			private var h:String;
			/**
			 * Transforme un timestamp en HHhMMmSS.
			 */
			private function timestampToHeure(timestamp:Number):String
			{
				var time:Date = new Date(timestamp);
				h = time.getHours() + "h";
				h += time.getMinutes() < 10 ? "0" + time.getMinutes() : time.getMinutes();
				h += "m";
				h += time.getSeconds() < 10 ? "0" + time.getSeconds() : time.getSeconds();
				return h;
			}
			
			
			
			/**
			 * Label Function de la colonne Enregistré.
			 */
			private function labelFuncTimestampToHeure(item:Object, column:DataGridColumn):String
			{
				if(item.@registered != "0"){
					return timestampToHeure(item.@registered);
				} else {
					return "0";	
				}
			}
			
			
			
			/**
			 * Label Function de la colonne Salle.
			 */
			private function labelFuncNomSalle(item:Object, column:DataGridColumn):String
			{
				return this["SALLE_" + item.@salle];
			}
			
			
			private var date_debut:Date;
			private var date_fin:Date;
			/**
			 * 
			 */
			private function stockDateRange(_range:Array):void {
				if (_range != null) {
					date_debut = new Date(_range[0].rangeStart);
					date_fin = new Date(_range[0].rangeEnd);
					
					date_debut.setHours(0, 0, 0, 0);
					date_fin.setHours(23, 59, 59, 999);
					
					//trace("Range selected: " + date_debut.getFullYear().toString() + "/" + (date_debut.getMonth()+1).toString() + "/" + date_debut.getDate() + " - " + date_debut.getHours() + "h" + date_debut.getMinutes() + " -- " + date_fin.getFullYear().toString() + "/" + (date_fin.getMonth()+1).toString() + "/" + date_fin.getDate() + " - " + date_fin.getHours() + "h" + date_fin.getMinutes() + "m" + date_fin.getSeconds() + "s" + date_fin.getMilliseconds());
				}
			}
			
			
			/**
			 * Récupère la liste des conférences correpondant aux dates
			 * sélectionnées dans le calendrier.
			 */
			private function boutonDatesClic(event:MouseEvent):void
			{
				recupListeConferences(date_debut, date_fin);
			}
			
			
			
			/**
			 * Lors de saisie de texte dans le champ de recherche.
			 */
			private function changeTexteTrouverPersonneListe(event:Event):void
			{
				trouverPersonneListe(event.currentTarget.text);
			}
			
			
			
			/**
			 * Recherche un inscrit dans la liste, le sélectionne et scroll si besoin.
			 */
			private function trouverPersonneListe(_lettres:String = ""):void
			{				
				trierListe();
				
				var lettresLength:int = _lettres.length;
				
				DataGrid(xmlDataGrid).selectedItem = null;
				DataGrid(xmlDataGrid).scrollToIndex(0);
				
				if(lettresLength > 0){
					for each(var inscrit:XML in DataGrid(xmlDataGrid).dataProvider){
						if(String(inscrit.nom).substr(0, lettresLength).toUpperCase() == _lettres.toUpperCase()){
							DataGrid(xmlDataGrid).selectedItem = inscrit;
							DataGrid(xmlDataGrid).scrollToIndex(DataGrid(xmlDataGrid).selectedIndex);
							break;
						}
					}
				}
			}
			
			
			
			/**
			 * Tri la liste des inscrits par nom, puis prénom.
			 */
			private function trierListe():void
			{
				var myDP:XMLListCollection = DataGrid(xmlDataGrid).dataProvider as XMLListCollection;
				
				var sortNomsPrenoms:Sort = new Sort();
				sortNomsPrenoms.fields = [new SortField("nom", true, false), new SortField("prenom", true, false)];
				myDP.sort= sortNomsPrenoms;
				myDP.refresh();
			}
			
			
			
			/**
			 * Si CheckBox recherche cochée, met le focus sur champ de recherche.
			 * 
			 * Si non cochée, vide le contenu du champ de recherche.
			 */
			private function initChampRecherche(event:MouseEvent):void
			{
				if(CheckBox(event.target).selected) {
					champRecherche.setFocus();
				} else {
					champRecherche.text = "";
				}
			}
			
			
			
			/**
			 *Fonction supprimant les espaces et les sauts de lignes en fin et début de String ;)
			 */
			private function trim(s:String):String
			{
				return s.replace( /^([\s|\t|\n]+)?(.*)([\s|\t|\n]+)?$/gm, "$2" );
			}
			
			
		]]>
	</fx:Script>
	
	<s:Group width="100%" height="100%">
		
		<s:Rect width="100%" height="100%">
			<s:fill>
				<s:SolidColor color="{COULEUR_FOND}" />
			</s:fill>
		</s:Rect>
		
		<s:VGroup height="100%" width="100%" gap="0">
			
			<!-- ENTETE -->
			<s:Group width="100%" height="90">
				<s:Rect width="100%" height="100%">
					<s:fill>
						<s:SolidColor color="{COULEUR_ROUGE}" />
					</s:fill>
				</s:Rect>
		
				<s:HGroup verticalAlign="middle" width="100%" height="90" paddingBottom="10" paddingLeft="20" paddingRight="10" paddingTop="10">
					<s:BitmapImage source="{logoBlancClass}" />
					<s:Label text=" / ÉVÉNEMENTS" color="#FFFFFF" fontSize="29" paddingTop="10" fontFamily="Arial"/>
					<s:HGroup width="100%" horizontalAlign="right">
						<s:Label text="{heure}" color="#FFFFFF" fontSize="29" paddingTop="10" paddingRight="10" fontFamily="Arial"/>
					</s:HGroup>
				</s:HGroup>
			</s:Group>
			
			<!-- MENU PRINCIPAL -->
			<mx:HBox width="100%" height="30" backgroundColor="{COULEUR_MENU}">
				<mx:Canvas width="100%" height="100%">
					<mx:HBox width="100%" height="30" backgroundColor="{COULEUR_MENU}" visible="{vues.selectedChild == vue_download}">		
						<s:Button id="bt_xml" color="{COULEUR_TEXTE_MENU}" height="30" label="CHARGER UN FICHIER XML EXTERNE" click="selectLocalXML(event)" fontWeight="bold" skinClass="skins.ButtonMenu" buttonMode="true"/>
					</mx:HBox>
					<mx:HBox width="100%" height="30" backgroundColor="{COULEUR_MENU}" visible="{vues.selectedChild == vue_liste}">	
						<s:Button id="bt_accueil" color="{COULEUR_TEXTE_MENU}" height="30" label="RETOUR A L'ACCUEIL" click="clicBtAccueil(event)" fontWeight="bold" skinClass="skins.ButtonMenu" buttonMode="true"/>
						<s:Button id="bt_csv" color="{COULEUR_TEXTE_MENU}" height="30" label="EXPORTER LA CONFERENCE EN CSV" click="saveConfCSV()" fontWeight="bold" skinClass="skins.ButtonMenu" buttonMode="true"/>
					</mx:HBox>
				</mx:Canvas>
				<mx:HBox width="100%" height="30" backgroundColor="{COULEUR_MENU}" horizontalAlign="right">
					<s:Button id="bt_3" color="{COULEUR_TEXTE_MENU}" height="30" label="{fullscreen_state ? 'MINIMISER' : 'PLEIN ECRAN'}" fontWeight="bold" click="toggleFullScreen()" skinClass="skins.ButtonMenu" buttonMode="true"/>
					<s:Button id="bt_4" color="{COULEUR_TEXTE_MENU}" height="30" label="QUITTER" fontWeight="bold" click="fermetureApplication()" skinClass="skins.ButtonMenu" buttonMode="true"/>
				</mx:HBox>
			</mx:HBox>
			
			<!-- VUES -->
			<mx:ViewStack id="vues" height="100%" width="100%" >
				
				<!-- ACCUEIL -->
				<s:NavigatorContent id="vue_accueil" height="100%" width="100%" >
					
					<s:Group height="100%" width="100%">
						
						<s:VGroup height="100%" width="100%" color="{COULEUR_TEXTE}" horizontalAlign="center" verticalAlign="middle">
							
							<s:Label text="Bienvenue !" />
							<s:Label id="lbEtatConnexion" />
							
						</s:VGroup>
						
					</s:Group>
					
				</s:NavigatorContent>
				
				<!-- CONFERENCES -->
				<mx:HBox id="vue_download" width="100%" height="100%" horizontalGap="10" horizontalAlign="center" backgroundColor="{COULEUR_FOND}" paddingLeft="10" paddingTop="10" paddingBottom="10">
					
					<mx:VBox width="200" height="100%" verticalGap="0" visible="{etatInternet}" horizontalAlign="center">
						<mx:DateChooser id="dateChooser1" width="100%" selectedRanges="{[{rangeStart: new Date(), rangeEnd: (new Date(Number(new Date().getTime() + (7*24*60*60*1000))))}]}" yearNavigationEnabled="false" allowMultipleSelection="true" headerColors="{[COULEUR_SAUMON, COULEUR_SAUMON]}" fontWeight="bold" todayColor="{COULEUR_SAUMON}" firstDayOfWeek="1"
										change="stockDateRange(DateChooser(event.target).selectedRanges)" />
						<s:Button label="VALIDER" click="boutonDatesClic(event)" skinClass="skins.ButtonAlert" width="100%" height="30" fontWeight="bold" buttonMode="true"/>
						<mx:Spacer height="20"/>
						<s:Label width="100%" height="100%" text="Pour sélectionner la première date, faites un « Clic Gauche » dessus.{'\n\n'}Pour sélectionner la deuxième date, faites « Shift + Clic Gauche » dessus." />
					</mx:VBox>
					
					<mx:VBox width="100%" height="100%" visible="{etatInternet}" horizontalAlign="center" verticalAlign="middle" backgroundColor="{COULEUR_FOND}" verticalGap="0" paddingTop="10" paddingBottom="10">
						
						<mx:Repeater id="confRepeater">
							
							<myComp:ButtonConference2 date="{formaterDate(XMLList(confRepeater.currentItem)..date)}" horaire="{formaterHoraire(XMLList(confRepeater.currentItem)..horaire)}" titre="{XMLList(confRepeater.currentItem)..titre}" backgroundColor="{boutConfAltColor(confRepeater.currentIndex)}" width="800" height="50" click="clickConference(event)" buttonMode="true"/>
							
						</mx:Repeater>
						
					</mx:VBox>
					
				</mx:HBox>	
				
				<!-- SCAN -->
				<s:NavigatorContent id="vue_liste" height="100%" width="100%" show="initScan(event)">
						
					<s:HGroup height="100%" width="100%" gap="10" paddingLeft="10" paddingRight="10" paddingTop="10" paddingBottom="10">
					
						<!-- COLONNE GAUCHE -->
						<s:VGroup height="100%" width="50%" gap="10">	
							
							<s:HGroup>
								<s:TextInput id="champRecherche" width="160" change="changeTexteTrouverPersonneListe(event)" enabled="{cbxRecherche.selected}"/>
								<s:CheckBox id="cbxRecherche" label="RECHERCHE PAR NOM" click="initChampRecherche(event)"/>
							</s:HGroup>
							
							<myComp:RowColorDataGrid id="xmlDataGrid" width="100%" height="100%" doubleClickEnabled="true" itemDoubleClick="ajoutInscritManuellement(event)" selectable="true">
								<myComp:columns>
									<mx:DataGridColumn dataField="*" headerText="*" visible="false" />
									<mx:DataGridColumn dataField="nom" headerText="Nom"/>
									<mx:DataGridColumn dataField="prenom" headerText="Prénom" />
									<mx:DataGridColumn dataField="@code" headerText="Code Barre" width="105"/>
									<mx:DataGridColumn dataField="@statut" headerText="Statut" textAlign="center"/>
									<mx:DataGridColumn dataField="@salle" headerText="Salle" labelFunction="labelFuncNomSalle"/>
									<mx:DataGridColumn dataField="@registered" headerText="Enregistré" textAlign="center" width="80" labelFunction="labelFuncTimestampToHeure"/>
								</myComp:columns>
							</myComp:RowColorDataGrid>
						
						</s:VGroup>
							
						<!-- COLONNE DROITE -->
						<s:VGroup width="50%" height="100%" gap="10">
						
							<!-- INFOS SCAN -->
							<s:Group width="100%" height="100%">
								
								<s:Rect width="100%" height="100%">
									<s:fill>
										<s:SolidColor color="{COULEUR_SAUMON}"/>
									</s:fill>
								</s:Rect>
							
								<s:VGroup gap="40" width="100%" height="100%" verticalAlign="middle" paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10">
										<s:Label text="{salleUtilisateur.toUpperCase()}" fontSize="50" maxDisplayedLines="2"/>
										<s:VGroup gap="10">
											<s:Label text="{utilisateur.prenom}" width="100%" fontSize="30" fontWeight="bold" maxDisplayedLines="1"/>	
											<s:Label text="{utilisateur.nom}" width="100%" fontSize="30" fontWeight="bold" maxDisplayedLines="1"/>	
											<s:Label text="{utilisateur.@code}" width="100%" fontSize="30" fontWeight="bold" maxDisplayedLines="1"/>	
										</s:VGroup>
									
								</s:VGroup>
							</s:Group>
							
							<s:Group width="100%" height="50">
								
								<s:Rect width="100%" height="100%">
									<s:fill>
										<s:SolidColor color="{etatUtilisateur == 'OK' ? (utilisateur.@salle == 1 ? COULEUR_VERTE : COULEUR_BLEUE) : COULEUR_ROUGE}"/>
									</s:fill>
								</s:Rect>
								
								<s:Label text="{etatUtilisateur}" width="100%" color="0xFFFFFF" fontSize="40" fontWeight="bold" paddingLeft="10" paddingTop="10"/>
							</s:Group>
									
							<!-- CHAMP DE SAISIE -->
							<s:Group width="100%" height="40">
								<s:HGroup gap="0" width="100%" height="100%" horizontalCenter="0" verticalAlign="middle">
									<s:TextInput id="codeInput" enabled="{!cbxRecherche.selected}" color="#000000" fontSize="30" maxChars="13" restrict="0-9" width="100%" height="100%" borderVisible="false" focusAlpha="0" />
									<s:Button label="VALIDER" click="soumissionCodebarre(null)" width="160" height="100%" color="#FFFFFF" fontSize="30" buttonMode="true" skinClass="skins.ButtonMenu" />
								</s:HGroup>
							</s:Group>
									
							<!-- PLACES -->
							<s:VGroup gap="0" width="100%" height="100%">	
								<s:Group width="100%" height="100%" fontSize="15" fontWeight="bold">
									<s:Rect width="100%" height="100%">
										<s:fill>
											<s:SolidColor color="{COULEUR_SAUMON}"/>
										</s:fill>
									</s:Rect>
								
									<s:VGroup gap="10" width="100%" height="100%" minHeight="190" paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10">	
										<s:Label text="{String(conference..titre).toUpperCase()}" width="100%" height="40" maxDisplayedLines="2"/>
										<s:HGroup width="100%" gap="0">
											<s:VGroup width="100%">
												<s:Label text=""/>
												<s:VGroup gap="5" width="100%" fontWeight="normal">
													<s:Label text="Nombre de places :"/>
													<s:Label text="Inscrits :"/>
													<s:Label text="Enregistrés :"/>
													<s:Label text="Non-inscrits :"/>
													<s:Label text="Reste :" color="{COULEUR_ROUGE}"/>
												</s:VGroup>			
											</s:VGroup>
												
											<s:VGroup id="salle0" width="160" maxWidth="160" horizontalAlign="right">	
												<s:Label text="{SALLE_1.toUpperCase()}"/>
												<s:VGroup gap="5" horizontalAlign="right">
													<s:Label text="{conference..salles.salle[0].@places}"/>
													<s:Label text="{conference..salles.salle[0].@inscrits}"/>
													<s:Label text="{conference..salles.salle[0].@presents}"/>
													<s:Label text="{conference..salles.salle[0].@noninscrits}"/>
													<s:Label text="{conference..salles.salle[0].@reste}" color="{COULEUR_ROUGE}"/>
												</s:VGroup>	
											</s:VGroup>
											
											<s:VGroup id="salle1" width="160" maxWidth="160" horizontalAlign="right">	
												<s:Label text="{SALLE_2.toUpperCase()}"/>
												<s:VGroup gap="5" horizontalAlign="right">
													<s:Label text="{conference..salles.salle[1].@places}"/>
													<s:Label text="{conference..salles.salle[1].@inscrits}"/>
													<s:Label text="{conference..salles.salle[1].@presents}"/>
													<s:Label text="{conference..salles.salle[1].@noninscrits}"/>
													<s:Label text="{conference..salles.salle[1].@reste}" color="{COULEUR_ROUGE}"/>
												</s:VGroup>	
											</s:VGroup>
											
										</s:HGroup>
									</s:VGroup>
								</s:Group>
								
								<!-- BOUTONS AJOUT NON INSCRITS -->
								<s:HGroup width="100%" height="100%" gap="0" horizontalAlign="right" fontSize="12" fontWeight="bold">
									<s:Button label="{String('Ajouter non-inscrit\nen ' + SALLE_1).toUpperCase()}" click="ajoutNonInscrit(0)" width="160" height="40" color="0xFFFFFF" skinClass="skins.ButtonMenu" buttonMode="true" />
									<s:Button label="{String('Ajouter non-inscrit\nen ' + SALLE_2).toUpperCase()}" click="ajoutNonInscrit(1)" width="160" height="40" color="0xFFFFFF" skinClass="skins.ButtonMenu" buttonMode="true" />
								</s:HGroup>
								
							</s:VGroup>
							
						</s:VGroup>
						
					</s:HGroup>
					
					<s:Rect id="rectFlashOK" width="100%" height="100%" visible="false">
						<s:fill>
							<s:SolidColor color="{utilisateur.@salle == 1 ? COULEUR_FLASH_OK_1 : COULEUR_FLASH_OK_2}" alpha=".6"/>
						</s:fill>
					</s:Rect>
				
				</s:NavigatorContent>
			
			</mx:ViewStack>
		
		</s:VGroup>
	
	</s:Group>
	
</s:WindowedApplication>
